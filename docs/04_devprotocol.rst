Adding a protocol to a backend
===============================

Overview
---------------

.. note::
    Examples below are all based on the already implemented openvpn udp protocol for NetworkManager.

``VPNConnection`` is the base class which all backends should extend from. In this specific case ``NMConnection``
derives from ``VPNConnection`` and ``NMClient`` (the latter is used to communicate with NetworkManager via python).
The class dependency is shown below:

.. code-block:: ascii

                                +-------------------+
                                |                   |
                                |   VPNConnection   |
                                |                   |
                                +---+---------------+
                                    |               
                                    |               
                        +-----------v------+
                        |                  |
                        |   NMConnection   |
                        |                  |
                        +-----------+------+
                                    |
                                    |
                        +-----------v------+
                        |                  |
                        |      OpenVPN     |
                        |                  |
                        +--+-------------+-+ 
                           |             |
                           |             |
          +----------------v--+        +-v-----------------+
          |                   |        |                   |
          |   OpenVPNUDP      |        |     OpenVPNTCP    |
          |                   |        |                   |
          +-------------------+        +-------------------+

NMConnection
---------------

Each protocol that extends from ``NMConnection`` has to implement 2 class properties (``protocol`` and ``_persistence_prefix``) and one method (``_setup()``).

Protocol is needed for two cases:

* To return the selected vpn connection protocol from the factory
* As prefix for persistence

Persistence prefix is needed for persisting connections:

* To identify the status of the vpn connection or
* If you want to disconnect the vpn outside the execution flow of your application (see ``down()`` method)
* If you want recover from a crash that has left stale states on the host.

The prefix has to follow a specific pattern. The first part of the prefix specifies the backend, while the second part consists of the protocol which then is followed by unique id of the connection
(which should always be generated and set in the ``_setup()`` method).
In the following exempel, since we're using the NM backend with the openvpn udp protocol, the prefix would look something like this:
``nm_openvpn_udp_<UNIQUE_ID>`` where ``<UNIQUE_ID>`` is an ID which is either generated by NM or by your ``_setup()`` method and set to ``self._unique_id``.

Taking a look at the ``up()`` and ``down()`` methods in ``NMConnection``, we can see that that they're quite small:

up()
#####

#. The ``up()`` method calls on ``_setup()``, which at this point all subclasses should've have overriden and implemented it's own setup method,
#. then ``_persist_connection()``, which persists the connection to a file based on ``protocol`` and ``_persistence_prefix`` and lastly
#. the connection is started with ``_start_connection_async``, which is inherited from ``NMClient``, available in ``NMConnection`` and dedicated
   to dbus RPC with Network Manager.

.. code-block:: python

    def up(self):
        self._setup()
        self._persist_connection()
        self._start_connection_async(self._get_protonvpn_connection())

down()
#######

#. The ``down()`` is quite simple, as it mainly removes the connection (which in turn also disconnects, but that is done in the background) and then
#. connection persistence is removed

.. code-block:: python

    def down(self):
        self._remove_connection_async(self._get_protonvpn_connection())
        self._remove_connection_persistence()

Persistence
---------------

In this chapter we'll see a bit how persistence works. If we further look what ``_persist_connection()`` does:

.. code-block:: python

        from ..persistence import ConnectionPeristence
        persistence = ConnectionPeristence()
        conn_id = self._persistence_prefix + self._unique_id
        persistence.persist(conn_id)

As seen here, persistence is depends on two variables, ``_persistence_prefix`` and ``_unique_id``. As briefly explained in :ref:`NMConnection<NMConnection>`,
``_persistence_prefix`` should follow a specific format, while ``_unique_id`` has to be set during ``_setup()``, so that the connection can persist properly.
In the case of OpenVPN, the unique id is set after importing the conneciton into NM and getting it from the settings, since the UUID has been automatically
generated by NM:

.. code-block:: python

    self._unique_id = self.__connection_settings.get_uuid()

.. note::
    To be able to persist a connection, all classes that extend from ``NMConnection`` need to set the unique id to ``self._unique_id`` in their ``_setup()`` method.


OpenVPN
---------------

OpenVPNUDP
---------------

Let start by taking a closer look at ``OpenVPNUDP`` as it actually extends from ``OpenVPN`` (which in itself extends from ``VPNConnection`` + ``NMClient``):

.. code-block:: python

    class OpenVPNUDP(OpenVPN):
        """Creates a OpenVPNUDP connection."""
        protocol = "openvpn_udp"
        _persistence_prefix = "nm_{}_".format(protocol)

        def _setup(self):
            from ..vpnconfiguration import VPNConfiguration
            vpnconfig = VPNConfiguration.from_factory(self.protocol)
            vpnconfig = vpnconfig(self._vpnserver, self._vpncredentials, self._settings)
            vpnconfig.use_certificate = self._use_certificate

            self._configure_connection(vpnconfig)
            self._add_connection_async(self.connection)

As it can be seen, the protocol class has implemented 2 class properties (``protocol`` and ``_setup``), one method (``_setup()``) and the format of the prefix,
as previously explained in :ref:`NMConnection<NMConnection>`.

Since most of the logic resides in ``OpenVPN``, the classes that extend from it are rather small.


.. note::
    There are multiple ways to add connections to NM. ``OpenVPNUDP`` for example uses ``VPNConfig`` factory to get a file that can be imported into NM via a plugin.
    But certain protocols imports might not be supported for all protocols, as the plugins for those do might exist or do not work properly,
    thus you might have to manually build a connection with ``dbus-python`` and add ``NM``.


Wireguard
----------------

Now we'll try to add the wireguard protocol to ``NMConnection``, based on previous explanation.

1. We'll start by extending from the backend class

.. code-block:: python

    class Wireguard(NMConnection):
        pass

2. Then we'll add the necessary class properties and method to the class

.. code-block:: python

    protocol = "wireguard"
    # Since we're deriving from NM, the prefix should always contain nm_ so that we know about which backend we're talking about,
    # given that there can be multiple backends
    _persistence_prefix = "nm_{}_".format(protocol)

    def _setup(self):
        pass

3. Depending on how the connection is added to NetworkManager, you'll have to either create the UUID before or after adding the connection to NM. See :ref:`OpenVPNUDP<OpenVPNUDP>` and :ref:`Persistence<Persistence>`.

At this point, the class should look like this:

.. code-block:: python

    class Wireguard(NMConnection):
        protocol = "wireguard"
        _persistence_prefix = "nm_{}_".format(protocol)

    def _setup(self):
        # create connection
        # add connection to NM
        # set `self._unique_id` variable
        # connection is ready to be used

4. Given that setup is correct and that the ``self._unique_id`` is set, you can use this vpn connection to establish a wireguard vpn tunnel.

